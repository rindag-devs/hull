/*
  This file is part of Hull.

  Hull is free software: you can redistribute it and/or modify it under the terms of the GNU
  Lesser General Public License as published by the Free Software Foundation, either version 3 of
  the License, or (at your option) any later version.

  Hull is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
  the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser
  General Public License for more details.

  You should have received a copy of the GNU Lesser General Public License along with Hull. If
  not, see <https://www.gnu.org/licenses/>.
*/

{ lib, pkgs }:

{
  # Name of the lemon problem target to use for each problem.
  # A Lemon contest target requires a corresponding lemon problem target on each problem.
  problemTarget ? "lemon",
}:
{
  _type = "hullContestTarget";
  __functor =
    self:
    {
      name,
      problems,
      ...
    }:
    let
      # Get the output paths of the specified lemon problem target for each problem.
      problemOutputs = map (p: p.config.targetOutputs.${problemTarget}) problems;
      # Get the paths to the individual .cdf files generated by each problem target.
      problemCdfPaths = map (
        p: "${p.config.targetOutputs.${problemTarget}}/${p.config.name}.cdf"
      ) problems;
      numTasks = builtins.length problems;
    in
    pkgs.runCommandLocal "hull-contestTargetOutput-${name}-lemon" { } ''
      # Create the basic directory structure for the contest.
      mkdir -p $out/data $out/source

      # Merge the 'data' and 'source' directories from all problem targets.
      # - Data files from different problems are merged into a single 'data' directory.
      # - Source files are merged on a per-contestant basis.
      for problemOutput in ${lib.concatStringsSep " " problemOutputs}; do
        # Merge data files
        cp -r $problemOutput/data/* $out/data/

        # Merge source files for each contestant
        for contestantDir in $problemOutput/source/*; do
          if [ -d "$contestantDir" ]; then
            contestantName=$(basename "$contestantDir")
            mkdir -p $out/source/$contestantName
            cp -r "$contestantDir"/* $out/source/$contestantName/
          fi
        done
      done

      # Generate the unified .cdf file using jq.
      # - This involves creating a new JSON object and populating it by merging
      # - data from the individual problem .cdf files.

      # Create an initial empty contest JSON structure.
      ${lib.getExe pkgs.jq} -cn \
        --arg version "1.0" \
        --arg title "${name}" \
        '{version: $version, contestTitle: $title, tasks: [], contestants: []}' \
        > $out/${name}.cdf

      # Append each problem's task definition to the main .cdf file.
      for cdf_path in ${lib.concatStringsSep " " problemCdfPaths}; do
        ${lib.getExe pkgs.jq} -c --slurpfile prob_cdf "$cdf_path" \
          '.tasks += $prob_cdf[0].tasks' \
          $out/${name}.cdf > tmp.json && mv tmp.json $out/${name}.cdf
      done

      # Get the list of all unique contestant names from the merged 'source' directory.
      contestantNames=$(ls $out/source 2>/dev/null || true)

      # For each contestant, create a complete entry in the .cdf file.
      # This entry must include placeholders for every task in the contest.
      for contestantName in $contestantNames; do
        # Generate the array structures needed for a contestant entry.
        # The length of these arrays must match the total number of tasks.
        checkJudgedStr=$(printf 'false,%.0s' $(seq ${toString numTasks}) | sed 's/,$//')
        compileStateStr=$(printf '1,%.0s' $(seq ${toString numTasks}) | sed 's/,$//') # 1 = NoValidSourceFile
        emptyStr=$(printf '"",%.0s' $(seq ${toString numTasks}) | sed 's/,$//')
        emptyArr=$(printf '[],%.0s' $(seq ${toString numTasks}) | sed 's/,$//')

        # Use jq to construct the contestant JSON object and append it to the 'contestants' array.
        ${lib.getExe pkgs.jq} -c \
          --arg name "$contestantName" \
          --argjson check_judged_str "[$checkJudgedStr]" \
          --argjson compile_state_str "[$compileStateStr]" \
          --argjson empty_str "[$emptyStr]" \
          --argjson empty_arr "[$emptyArr]" \
          '.contestants += [{
            contestantName: $name,
            checkJudged: $check_judged_str,
            compileState: $compile_state_str,
            sourceFile: $empty_str,
            compileMesaage: $empty_str,
            inputFiles: $empty_arr,
            result: $empty_arr,
            message: $empty_arr,
            score: $empty_arr,
            timeUsed: $empty_arr,
            memoryUsed: $empty_arr,
            judgingTime_date: 0,
            judgingTime_time: 0,
            judgingTime_timespec: 0
          }]' \
          $out/${name}.cdf > tmp.json && mv tmp.json $out/${name}.cdf
      done
    '';
}
